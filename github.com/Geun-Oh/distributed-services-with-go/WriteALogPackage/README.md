- 로그는 추가만 할 수 있는 레코드의 연속.
- 레코드는 로그 끝에 추가, 보통 최근의 로그들을 오래된 레코드부터 읽는다.
- 이전에는 사람이 읽을 수 있는 문자열의 의미로 써왔으나, 최근에는 바이너리로 인코딩된 메세지의 의미가 더 커졌다.
- 로그에 레코드를 추가하면, 로그는 레코드에 고유하며 순차적인 오프셋 숫자를 할당한다.
- offset == id
- 로그는 레코드의 오프셋과 생성 시간으로 정렬된 데이터베이스 테이블과 같다.

- 로그의 무한정 추가가 불가하므로 로그를 여러 세그먼트로 나눈다.
- 세그먼트는 하나의 파일과 같으며, 메세지의 내용 뿐 아니라 key, value, offset, message size와 같은 정보가 함께 저장되는 하나의 단위이다.
- 오래된 세그먼트부터 지우며 디스크 용량을 확보한다.
- Producer <=> Consumer 개념을 적용한다.
- 여기서 고루틴들이 같은 데이터에 접근하더라도 충돌이 거의 일어나지 않는다.(?왜그런거죠...?)

- 세그먼트 목록에는 항상 하나의 활성 세그먼트가 존재한다.
- 유일하게 레코드 작성이 가능한 세그먼트이다.
- 활성 세그먼트가 가득 차면 새로운 세그먼트를 생성해 활성 세그먼트로 만든다며

- 세그먼트는 저장파일과 인덱스파일로 구분된다.
- 저장 파일은 레코드 데이터를 저장하고 추가해나가며, 인덱스 파일은 그 레코드들의 인덱스를 저장한다.
- 인덱스 파일은 레코드의 오프셋을 저장 파일의 실제 위치로 매핑해서 빠르게 데이터를 읽도록 한다.
- 인덱스 파일은 오프셋과 저장 파일 내 위치라는 두 필드만을 가지므로 저장소 파일보다 훨씬 작다. 따라서 메모리 맵 파일로 만들어 파일 연산이 아닌 메모리 데이터를 다루듯 빠르게 만들 수 있다.

내용을 요약하면 다음과 같다.

- 레코드: 로그에 저장한 데이터
- 저장 파일: 레코드를 저장하는 파일
- 인덱스 파일: 인덱스를 저장하는 파일
- 세그먼트: 저장 파일과 인덱스 파일을 묶어 말하는 추상적 개념
- 로그: 모든 세그먼트를 묶어서 말하는 추상적 개념
